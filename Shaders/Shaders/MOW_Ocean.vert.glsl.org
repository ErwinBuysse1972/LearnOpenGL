#version 410

layout(location = 0) in vec3 VertexPosition;
layout(location = 1) in vec3 VertexNormal;

out vec3 Position;
out vec3 Normal;

// fog out
out vec4 voAdditiveColor;
//out vec4 voColor0;
//out vec4 vov4MiscData_Mrn;
out vec4 voSkyLightFogParameters;
out vec4 voSkylight_ambient;
out vec4 voSkylight_diffuse;
//out vec4 voVertexNormal;
//out vec3 voOutPosEye;
//out vec3 voPosClip;


uniform mat4 ModelViewMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 MVP;

uniform struct VegaPrime
{
    vec4 m_vpEnv_ambientColor_0;
    vec4 m_vpEnv_blueHorizon_0;
    vec4 m_vpEnv_hazeHorizon_0;
    vec4 m_vpEnv_sunlight_0;
    vec4 m_vpEnv_blueWeight_0;
    vec4 m_vpEnv_hazeWeight_0;
    vec4 m_vpEnv_temp1_0;
    vec4 m_vpEnv_glow_0;
    vec4 m_vpEnv_cameraPos_0;
    vec4 m_vpEnv_illumSunlightColor_0;
    vec4 m_vpEnv_lightNormal_0;
    vec4 m_vpMarine_v4Params0VS;
    vec4 m_vrLight_Position_0;
    vec4 m_vrMaterial_Diffuse_Front;
    vec3 m_vsChannel_AxisZEyeSpace;
    float m_vpEnv_cloudShadow_0;
    float m_vpEnv_densityMultiplier_0;
    float m_vpEnv_distanceMultiplier_0;
    float m_vpEnv_maxY_0;
    float m_vpEnv_cameraAltitude_0;
    float m_vpEnv_minColor_0;
    uint m_unLastWrite;
    mat4 m_vrTransform_ModelViewMatrixInverseTranspose;
    mat4 m_vrTransform_ModelViewProjectionMatrix;
}VP;


void skyLightAmbientDiffuseFog( vec4 vEyeSpacePos, out vec4 vLightDiffuse, out vec4 vLightAmbient, out vec4 vFogAdditiveColorSW, out vec3 OutSkyLightFogParams)
{
    // Shared variables
    vec4 light0Position = VP.m_vrLight_Position_0;
    vec3 skylightTemp1 = vec3(0.0, 0.0, 0.0);
    vec4 vlVpEnv_ambientColor_0 = VP.m_vpEnv_ambientColor_0;

    //---- skyLightAmbientDiffuseFog stage Begin

    //---- ffpSkyLightAmbientAndDiffuseLightColorAndFogColorComputation Atom Snippet Begin
    {

        vec3 densityMultiplier = vec3(VP.m_vpEnv_densityMultiplier_0, VP.m_vpEnv_blueWeight_0.a, VP.m_vpEnv_blueHorizon_0.a);
        vec3 distanceMultiplier = vec3(VP.m_vpEnv_distanceMultiplier_0, VP.m_vpEnv_hazeWeight_0.a, VP.m_vpEnv_hazeHorizon_0.a);

        // vEyeSpacePos is a vector from the eye to the vertex being shaded
        vec3 P = vEyeSpacePos.xyz;
        vec3 Pn = normalize(P);

        // pAltitude is the length of projection of the P vector onto
        // the vertical axis of the scene - the difference in height
        // between the observer's eye and the vertex being shaded.
        float pAltitude = dot(P, VP.m_vsChannel_AxisZEyeSpace);

        // Scale the P vector so that its vertical component falls
        // within the range of -vpEnv_maxY_0 to vpEnv_maxY_0.
        if (pAltitude > VP.m_vpEnv_maxY_0) P *= (VP.m_vpEnv_maxY_0 / pAltitude);
        if (pAltitude < -VP.m_vpEnv_maxY_0) P *= (-VP.m_vpEnv_maxY_0 / pAltitude);

        // Compute the skylight fog factor in three components.
        skylightTemp1.rgb = VP.m_vpEnv_temp1_0.rgb * P.z *
            densityMultiplier.rgb *
            distanceMultiplier.rgb;

        // Approximate the sun path distance and attenuate the sunlight
        // color which is stored in vpEnv_sunlight_0.rgb
        // sunVar controls the amount that attenuation color affects the
        // sunlight color (both diffuse and additive components).
        // Each sunlight color is affected by the vertical component of
        // the normalized direction from the observer to the dominant
        // celestial light source (vp_Env_sunlight_0.w).
        float sunVar = VP.m_vpEnv_sunlight_0.w;
        sunVar = 1.0 / max(0.0001, sunVar);
        vec3 sunlightDiffuse = VP.m_vpEnv_illumSunlightColor_0.rgb * exp(-VP.m_vpEnv_sunlight_0.rgb * sunVar);

        // The additive sunlight color is additionally affected by the
        // positive vertical component of a normalized vector from the
        // observer to the vertex in question.
        sunVar = max(0.0, dot(Pn, VP.m_vsChannel_AxisZEyeSpace)) +  VP.m_vpEnv_sunlight_0.w;
        sunVar = 1.0 / max(0.0001, sunVar);
        vec3 sunlightAdditive = VP.m_vpEnv_illumSunlightColor_0.rgb * exp(-VP.m_vpEnv_sunlight_0.rgb * sunVar);
        vlVpEnv_ambientColor_0.rgb += (vlVpEnv_ambientColor_0.rgb) * VP.m_vpEnv_cloudShadow_0 * 0.5;

        vec3 cameraPos = vec3(0.0, -VP.m_vpEnv_cameraAltitude_0, 0.0);
        pAltitude = dot(cameraPos, VP.m_vsChannel_AxisZEyeSpace);
        P = vEyeSpacePos.xyz;
        P.y -= pAltitude;
        Pn = normalize(P);
        sunVar = 1.0 - dot(Pn, light0Position.xyz);
        sunVar = max(sunVar * VP.m_vpEnv_glow_0.x, 0.001);
        sunVar = pow(sunVar, VP.m_vpEnv_glow_0.z) + 0.25;

        // Compute the skylight ambient and diffuse colors
        vLightDiffuse.rgb = sunlightDiffuse * 0.5;
        vLightAmbient.rgb = vlVpEnv_ambientColor_0.rgb * 0.25;

        // Compute the additive fog color
        vFogAdditiveColorSW.a = 1.0;
        vFogAdditiveColorSW.rgb =
            VP.m_vpEnv_blueHorizon_0.rgb * VP.m_vpEnv_blueWeight_0.rgb * (sunlightAdditive * (1.0 - VP.m_vpEnv_cloudShadow_0) +
            vlVpEnv_ambientColor_0.rgb) +
            (VP.m_vpEnv_hazeHorizon_0.rgb * VP.m_vpEnv_hazeWeight_0.rgb) * (sunlightAdditive * (1.0 - VP.m_vpEnv_cloudShadow_0) * sunVar + 
            vlVpEnv_ambientColor_0.rgb);

    }
    //---- ffpSkyLightAmbientAndDiffuseLightColorAndFogColorComputation Atom Snippet End

    //---- ffpSkyLightFogParametersPerFragment Atom Snippet Begin
    {

        vFogAdditiveColorSW.a = skylightTemp1.r;
        vLightAmbient.a = skylightTemp1.g;
        vLightDiffuse.a = skylightTemp1.b;

    }
    //---- ffpSkyLightFogParametersPerFragment Atom Snippet End

    //---- ffpPassSkyLightFogParamViaParam Atom Snippet Begin
    {
        OutSkyLightFogParams.rgb = skylightTemp1.rgb;

    }
    //---- ffpPassSkyLightFogParamViaParam Atom Snippet End

    //---- skyLightAmbientDiffuseFog stage End



}


void main()
{
    vec4 light0Ambient = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 light0Diffuse = vec4(0.0, 0.0, 0.0, 0.0);
    vec3 SkyLightFogParams = vec3(0.0, 0.0, 0.0);

    Normal = normalize(NormalMatrix * VertexNormal);
    
    vec4 vEyePos = ModelViewMatrix * vec4(VertexPosition, 1.0);
    skyLightAmbientDiffuseFog(vEyePos, light0Diffuse, light0Ambient, voAdditiveColor, SkyLightFogParams);

    // Fogging parameters are adjusted based on the range scale. This
// prevents blending to the fog color too early on the water for 
// narrow fields of view.
// Whether the ffpSkyLightFogParameters or the per-fragment variant
// is used, ensure voSkyLightFogParameters gets updated.
    voSkyLightFogParameters.rgb = SkyLightFogParams.rgb;
    voSkyLightFogParameters.rgb *= clamp(VP.m_vpMarine_v4Params0VS.x * 10.0, 0.5, 1.0);
    voSkylight_diffuse = light0Diffuse;
    voSkylight_ambient = light0Ambient;


    gl_Position = MVP * vec4(VertexPosition, 1.0);
}